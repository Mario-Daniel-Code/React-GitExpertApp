{"version":3,"sources":["Components/AddCategory.js","helpers/getGifs.js","Components/GifGridItem.js","Components/GifGrid.js","hooks/useFetchGifs.js","GitExpertApp.js","index.js"],"names":["AddCategory","setCategories","useState","inputValue","setInputValue","onSubmit","ev","preventDefault","trim","length","cats","type","onChange","target","value","getGifs","category","a","url","encodeURI","fetch","resp","json","data","gifs","map","img","id","title","images","downsized_medium","GifGridItem","className","src","alt","GifGrid","loading","state","setState","useEffect","then","imgs","useFetchGifs","console","log","GitExpertApp","categories","ReactDOM","render","document","getElementById"],"mappings":"mMAMaA,EAAc,SAAC,GAAuB,IAArBC,EAAoB,EAApBA,cAAoB,EACZC,mBAAS,IADG,mBACzCC,EADyC,KAC7BC,EAD6B,KA0BhD,OACE,sBAAMC,SAnBa,SAACC,GAEpBA,EAAGC,iBAMCJ,EAAWK,OAAOC,OAAS,IAK7BR,GAAc,SAACS,GAAD,OAAWP,GAAX,mBAA0BO,OACxCN,EAAc,MAKhB,SAKE,uBACEO,KAAK,OACLC,SA/BoB,SAACN,GAEzBF,EAAcE,EAAGO,OAAOC,a,+BCVfC,EAAO,uCAAG,WAAOC,GAAP,uBAAAC,EAAA,6DAIfC,EAJe,iDAIiCC,UAAUH,GAJ3C,+DAKFI,MAAMF,GALJ,cAKfG,EALe,gBAMEA,EAAKC,OANP,uBAMbC,EANa,EAMbA,KAGFC,EAAOD,EAAKE,KAAI,SAACC,GAAS,IAAD,EAC7B,MAAO,CACLC,GAAID,EAAIC,GACRC,MAAOF,EAAIE,MAEXV,IAAG,UAAEQ,EAAIG,cAAN,aAAE,EAAYC,iBAAiBZ,QAdjB,kBAkBdM,GAlBc,4CAAH,sDCCPO,EAAc,SAAC,GAAkB,IAAjBH,EAAgB,EAAhBA,MAAOV,EAAS,EAATA,IAGlC,OACE,sBAAKc,UAAU,yCAAf,UAEC,qBAAKC,IAAKf,EAAKgB,IAAKN,IACpB,4BAAIA,QCJIO,EAAU,SAAC,GAAkB,IAAhBnB,EAAe,EAAfA,SAAe,ECFb,SAACA,GAAa,MAIdd,mBAAS,CACjCqB,KAAM,GACNa,SAAS,IAN6B,mBAIjCC,EAJiC,KAI1BC,EAJ0B,KAgCxC,OAxBAC,qBAAU,WAERxB,EAAQC,GAAUwB,MAAK,SAACC,GACtBH,EAAS,CAEPf,KAAMkB,EAENL,SAAS,SAKZ,CAACpB,IAYGqB,ED5B2BK,CAAa1B,GAAjCa,EAFyB,EAE/BN,KAAca,EAFiB,EAEjBA,QAiBtB,OAhBAO,QAAQC,IAAIR,GAiBV,qCACE,oBAAIJ,UAAU,oCAAd,SAAmDhB,IAElDoB,GAAW,mBAAGJ,UAAU,mCAAb,qBAGZ,qBAAKA,UAAU,YAAf,SAWGH,EAAOJ,KAAI,SAACC,GAAD,OACV,cAAC,EAAD,eAKMA,GAJCA,EAAIC,aExCRkB,EAAe,WAAM,MAGI3C,mBAAS,CAC3C,gBAJ8B,mBAGzB4C,EAHyB,KAGb7C,EAHa,KAYhC,OACE,qCACE,8CAGA,cAAC,EAAD,CAAaA,cAAeA,IAC5B,uBAEA,6BAGI6C,EAAWrB,KAAI,SAAAT,GAAQ,OACrB,cAAC,EAAD,CAEAA,SAAYA,GADPA,Y,MCvBjB+B,IAASC,OACL,cAAC,EAAD,IACFC,SAASC,eAAe,W","file":"static/js/main.cbafeb39.chunk.js","sourcesContent":["import React, { useState } from \"react\";\nimport { PropTypes } from \"prop-types\";\n//export const AddCategory = (props) => {\n/* En ves de mandar las props es mejor \nllamar al componente setCategories desestructurado */\n\nexport const AddCategory = ({ setCategories }) => {\n  const [inputValue, setInputValue] = useState(\"\");\n  //Voy a extraer los que traiga en onchange, voy a recibir el evento\n  const handleInputChange = (ev) => {\n  \n    setInputValue(ev.target.value);\n  };\n\n  const handleSubmit = (ev) => {\n    //Para prevenir el comportamiento por defecto del formulario\n    ev.preventDefault();\n\n    //Esto no es comun hacerlo\n    //props.setCategories()\n    /*borrar espacios antes y despues si eso \n    es mayor a 2 letras, haga la insercion */\n    if (inputValue.trim().length > 2) {\n      /* Yo no tengo acceso a las categorias, asi que solo\n     mando referencia del setcategories con el input */\n     /* Llamamos a traer las exitentes y desoues las ultimas /\n      ahora inserte la nueva y despues las anteriores con el operador spread */\n      setCategories((cats) => [inputValue, ...cats]); //Segunda forma\n      setInputValue(\"\");\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      {/*  El formulario es el agrupamiento de varios elementos  */}\n      {/* Se vuelve a renderizar con el inputValue siempre,\n      va hacer el ultimo valor actualizado de lo que la persona escribio */}\n      {/* <h1>{inputValue}</h1> */}\n      <input\n        type=\"text\"\n        onChange={handleInputChange}\n        /* onChange={(ev) => console.log(ev) } El valor a la hora de teclear */\n      />\n    </form>\n  );\n};\n\nAddCategory.propTypes = {\n  setCategories: PropTypes.func.isRequired,\n};\n","//ocupa la category como argumento\nexport const getGifs = async (category) => {\n  /* Async Esta funcion regresa los gifs.\n  Regresa una promesa que resuleve la coleccion de mis imagenes */\n  //Vamos a llamar ese Endpoint Dragon+ball\n  const url = `https://api.giphy.com/v1/gifs/search?q=${encodeURI(category)}&limit=10&api_key=RZopC1do6uk2rHb38pCkTj4YxkpkqFp5`;\n  const resp = await fetch(url);\n  const { data } = await resp.json();\n\n  /* Mutar el arreglo que recibo para sea mas facil de ver  */\n  const gifs = data.map((img) => {\n    return {\n      id: img.id,\n      title: img.title,\n      //Usamos images? para preguntar si tiene las imagenes\n      url: img.images?.downsized_medium.url,\n    };\n  });\n\n  return gifs;\n\n  \n};\n","import React from 'react'\n\nexport const GifGridItem = ({title, url}) => {\n\n  //console.log(id, title, url); // le quiete las {}\n  return (\n    <div className='card animate__animated animate__bounce'>\n    \n     <img src={url} alt={title}/>\n     <p>{title}</p>\n    </div>\n  )\n}\n","//El useEffect nos va a permitir poder ejecutar cierto codigo de manera condicional\nimport React from \"react\";\nimport { useFetchGifs } from \"../hooks/useFetchGifs\";\nimport { GifGridItem } from \"./GifGridItem\";\n//Necesito recibir la categoria y hacer una peticion http\nexport const GifGrid = ({ category }) => {\n  //Aqui estamos usando el hook que creamos desestructuramos el state\n  const { data: images, loading } = useFetchGifs(category);\n  console.log(loading);\n\n  //const [images, setImages] = useState([]);\n  /* sig- solo quiero que se ejecute sta instr cuando \n  el componente es renderizsdo por primera vez  */\n  //Recibe una funcion, que quiero ejecutar\n  //useEffect(() => {\n  //Categoria la pongo como argumento y esto retorn a una promesa\n  //getGifs(category)\n  //.then(setImages);\n  /* Segundo argumento que le mandamos un arreglo de\n   dependencias, asi solo se disparara una vez la peticion fetch */\n  /* Si la categoria cambia va a volver a ejecutar ese efecto   */\n  //}, [category]);\n\n \n  return (\n    <>\n      <h3 className=\"animate__animated animate__bounce\">{category}</h3>\n      {/* Si es tru se evalua esto <p>Loading</p>  */}\n      {loading && <p className=\"animate__animated animate__flash\">Loading</p>}\n      {/* Operador ternario, ? si loading esta cargando : caso contrario fin de carga*/}\n\n      <div className=\"card-grid\">\n        {/* Expresion de javascript { }\n        Cuando no tengo las {} es un valor sig un return explicito\n         ,podemos desestructurar para ya no poner img.id  \n        { \n        images.map( img => (\n          <li key={img.id}>{img.title}</li>\n        ))\n        }*/}\n\n        {/* Podemos desestructurar para ya no poner img.id  */}\n        {images.map((img) => (\n          <GifGridItem\n            key={img.id}\n            /* Es bien usado esto operador spread { ...img }\n            Estoy mandando las propeties de las imagenes\n           como una propiedad independiente  id, title y url  */\n            {...img}\n          />\n        ))}\n      </div>\n    </>\n  );\n};\n","import { useEffect, useState } from \"react\";\nimport { getGifs } from \"../helpers/getGifs\";\n//Cuando se utilice el estdo del fetch se va a cargar por defecto\nexport const useFetchGifs = (category) => {\n  //pueden tener un estado, pueden indicar a los\n  //componentes cuando deben de renderizar porque algo cambio\n\n  const [state, setState] = useState({\n    data: [],\n    loading: true,\n  });\n  useEffect(() => {\n    //Esto es una promesa\n    getGifs(category).then((imgs) => {\n      setState({\n        //imagenes\n        data: imgs,\n        //ya termino de cargar\n        loading: false,\n      });\n    });\n    /* Evalua cuando la categoria cambia, \n    la primera vez cambia se va a disparar */\n  }, [category]);\n  /* Funcion propia de js, recibe el callback \n  que a los 3 seg va a ejecutar lo que sea adentro */\n  /* setTimeout(() => {\n    setState(\n      {\n        data: [1,2,3,4,5],\n        loading: false\n      }\n    )\n\n  }, 3000); */\n  return state; //{data[],loading: true}\n};\n","import React, { useState } from \"react\";\nimport { AddCategory } from \"./Components/AddCategory\";\nimport { GifGrid } from \"./Components/GifGrid\";\n\nexport const GitExpertApp = () => {\n  /* Const categories = ['One Punch', 'Samurai X', 'Dragon Ball'];\n   no se pueden mutar constantes */\n  const [categories, setCategories] = useState([\n    \"Dragon Ball\"\n  ]);\n\n  /*  const handleAdd = () => {\n    //Es usar el operador spread ...\n    //SetCategories(['Hunter', ...categories]); Primera opcion\n    setCategories((cats) => [...cats, \"Crash\"]); Segunda forma\n  }; */\n  return (\n    <>\n      <h2>GitExpertApp</h2>\n      {/*Se le pueden pasar propiedades al AddCategory, \n      le coloco set categories y la referencia del mismo*/}\n      <AddCategory setCategories={setCategories} />\n      <hr />\n      {/* <button onClick={handleAdd}>Agregar</button> */}\n      <ol>\n        {\n          //Un pequeÃ±o ciclo\n          categories.map(category => (\n            <GifGrid \n            key={category}\n            category = {category}\n            />\n          ))\n        }\n      </ol>\n    </>\n  );\n};\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { GitExpertApp } from './GitExpertApp';\nimport './index.css';\n\n\nReactDOM.render(\n    <GitExpertApp />,\n  document.getElementById('root')\n);\n\n\n"],"sourceRoot":""}